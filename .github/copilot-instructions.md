# GitHub Copilot Instructions for MoodyJW Portfolio

## Project Overview

This is a modern Angular 21 portfolio application built with standalone components, signals, and a feature-based architecture. The application demonstrates enterprise-grade patterns and best practices for scalable frontend development.

**Key Technologies:**

- Angular 21.0 with standalone components
- NgRx SignalStore for state management
- Transloco for internationalization (i18n)
- ng-icons for icon system
- Zod for runtime validation
- ngx-charts for data visualization
- Storybook for component documentation
- Playwright for E2E testing
- ESLint with Angular ESLint for code quality
- WCAG 2.1 AAA accessibility compliance
- npm overrides for package compatibility

**Project Decisions (recorded):**

- Analytics: GA4-only for Phase 1 (Looker Studio demos for embedding).
- Auth: Prioritize Ory (Kratos + Hydra) as the recommended open-source provider; Keycloak remains an alternate.
- Tests: Enforce tests before merge; coverage goal 85% (80% acceptable).
- Storybook: Host static Storybook under `/storybook` on GH Pages and attach PR preview artifacts in CI.

## Architecture Principles

### Package Compatibility Strategy

- Using **Angular 21.0** with TypeScript 5.9
- **npm overrides** configured in package.json for backward-compatible packages:
  - @ngrx/signals (Angular 20 → 21)
  - @swimlane/ngx-charts (Angular 18-20 → 21)
  - @storybook/angular (Angular 18-20 → 21)
- Zone.js imported in main.ts (required for Angular 21)
- Always use `--legacy-peer-deps` when adding new packages that may have peer dependency conflicts

### Folder Structure

- **Core**: Application-wide services, guards, interceptors, and layouts
- **Shared**: Reusable components, directives, pipes, and utilities
- **Features**: Feature modules (Home, Case Studies) with their own components and services

### Angular Standards

1. **Standalone Components**: All components MUST be standalone
2. **Signals**: Use signals for reactive state management
3. **Change Detection**: ALWAYS use `ChangeDetectionStrategy.OnPush` for all components
4. **Lazy Loading**: Feature routes MUST be lazy-loaded using dynamic imports

### Routing

- Routes are defined in `app.routes.ts`
- Use the `MainLayoutComponent` as a shell for all feature routes
- All feature components are lazy-loaded for optimal performance

### State Management (NgRx SignalStore)

- Use **NgRx SignalStore** for reactive state management
- **ProjectStore**: Central store for project/case study state
- Store provides computed selectors (projectCount, allTags, projectsByTag)
- Use `rxMethod` for async operations (loadProjects, loadProjectById)
- Automatic loading and error state management
- Inject store with `inject(ProjectStore)` in components
- Access state via signals: `store.projects()`, `store.isLoading()`
- **Integration Pattern**:

  ```typescript
  export class CaseStudiesComponent implements OnInit {
    readonly store = inject(ProjectStore);

    ngOnInit() {
      this.store.loadProjects();
    }
  }
  ```

- Replace hardcoded data arrays with store-managed state
- Use store loading/error states in templates with `@if` blocks

### Data Layer (Mockend Pattern)

- Mock data stored in `src/assets/data/*.json` files
- Services use `HttpClient` to fetch JSON data (allows easy transition to real APIs)
- **ProjectService**: Manages project/case study data from `projects.json`
- **latencyInterceptor**: Simulates 500-1000ms network delay for realistic development
- All HTTP requests go through the interceptor chain configured in `app.config.ts`

## Code Style Guidelines

### Linting (ESLint)

- Run `npm run lint` before committing code
- Fix auto-fixable issues with `npm run lint:fix`
- All ESLint errors must be resolved (no warnings in CI)
- Accessibility rules are enforced at WCAG 2.1 AAA level

### TypeScript

- Use strict type checking
- Prefer `const` over `let`
- Use readonly signals for data that shouldn't be mutated directly
- Avoid `any` types - use proper typing

### Component Structure

```typescript
import { Component, ChangeDetectionStrategy, signal } from '@angular/core';

@Component({
  selector: 'app-feature-name',
  standalone: true,
  imports: [],
  templateUrl: './feature-name.component.html',
  styleUrl: './feature-name.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class FeatureNameComponent {
  protected readonly data = signal<Type>(initialValue);
}
```

## Generated Files And Code-Review Guidance

Some files in this repository are generated by tools and should be ignored by automated code review helpers and Copilot-assisted reviews. In particular, Compodoc emits a set of generated HTML, JS, and TypeScript artifacts under `docs/compodoc/`. The built site copies those files into `dist/.../docs/compodoc/` during the Pages deploy.

Please skip reviewing or making suggestions for files under these paths:

- `docs/compodoc/**`
- `dist/**/docs/compodoc/**`

If you see Copilot or automated reviewers commenting on these files, treat them as false positives. When possible, modify the generator pipeline to include a short comment header in generated source-like files that indicates they are generated and should be ignored by automated reviews, for example:

```text
// GENERATED FILE - DO NOT EDIT
// This file is produced by Compodoc. Skip in code reviews and automated suggestions.
```

If you want, I can add a step in the Compodoc generation process that injects this header into generated TypeScript copies in `docs/compodoc/` so code review tools and Copilot will skip them automatically.

### Template Syntax

- Use Angular control flow (`@if`, `@for`, `@switch`) instead of structural directives
- Access signals with parentheses: `{{ mySignal() }}`
- Use `track` in `@for` loops for performance

### SCSS Styling

#### BEM Methodology

Use BEM (Block Element Modifier) naming convention:

```scss
.component-name {
  &__element {
    // element styles
  }

  &__element--modifier {
    // modifier styles
  }
}
```

#### CSS Variables

ALWAYS use CSS variables from the theme system:

**Colors**

- `--color-primary`, `--color-primary-hover`, `--color-primary-active`
- `--color-background`, `--color-surface`, `--color-surface-hover`
- `--color-text`, `--color-text-secondary`, `--color-text-tertiary`
- `--color-border`, `--color-border-hover`

**Spacing**

- `--spacing-xs` through `--spacing-4xl`

**Typography**

- `--font-size-xs` through `--font-size-5xl`
- `--font-weight-light` through `--font-weight-bold`
- `--font-family-base`, `--font-family-mono`

**Border Radius**

- `--border-radius`, `--border-radius-sm`, `--border-radius-lg`, `--border-radius-xl`

**Transitions**

- `--transition-duration`, `--transition-timing`

### File Organization

```
src/app/
├── core/
│   ├── layout/
│   ├── services/
│   ├── guards/
│   ├── interceptors/
│   └── models/
├── shared/
│   ├── components/
│   ├── directives/
│   ├── pipes/
│   └── utils/
└── features/
    ├── home/
    │   ├── components/
    │   ├── services/
    │   └── home.component.ts
    └── case-studies/
        ├── components/
        ├── services/
        └── case-studies.component.ts
```

## Development Workflow

### Adding a New Feature

1. Create feature folder under `features/`
2. Create main component with OnPush change detection
3. Add lazy route in `app.routes.ts`
4. Use signals for state management
5. Follow BEM naming for styles
6. Use CSS variables for theming

Documentation & Tests (required)

- For every new component or feature you add, follow the "docs-as-you-go" rule:
  - Add TSDoc comments for all public APIs (methods, inputs, outputs).
  - Create at least one Storybook story (`.stories.ts`) demonstrating the component's primary state(s) and include accessibility notes where relevant.
  - Add unit tests (Vitest) that cover component behavior, signal updates, and key edge cases.
- Small demo placeholder components are allowed, but MUST be listed in `DEMO_COMPONENTS.md` and migrated to include stories/tests before Phase 9.

### Adding a Shared Component

1. Create in `shared/components/`
2. Make it standalone
3. Use OnPush change detection
4. Accept inputs via `input()` signal
5. Emit outputs via `output()` signal

### Adding a Service

1. Place in appropriate folder (core/services or feature/services)
2. Use `providedIn: 'root'` or provide in component
3. Use signals or RxJS observables for state
4. Use `inject()` function for dependency injection (modern Angular pattern)
5. For data services, use HttpClient to fetch from assets/data/\*.json
6. Return Observables for async operations

### Using Icons (ng-icons)

1. Import icons from @ng-icons packages in component
2. Add to component imports array
3. Use `<ng-icon>` component in templates
4. Keep icon imports minimal (only import what you need)
5. **Example**:

   ```typescript
   import { NgIconComponent, provideIcons } from '@ng-icons/core';
   // Note: Install specific icon packs as needed, e.g.:
   // npm install @ng-icons/heroicons --legacy-peer-deps
   // import { heroHome, heroUser } from '@ng-icons/heroicons/outline';

   @Component({
     imports: [NgIconComponent],
     viewProviders: [provideIcons({ /* icons here */ })],
   })
   ```

### Internationalization (Transloco)

1. Translations are defined in `src/assets/i18n/{lang}.json`
2. Use `transloco` pipe or directive in templates
3. Available languages configured in `app.config.transloco.ts`
4. Use translation keys with dot notation: `'common.buttons.submit'`
5. Prefer translation keys over hardcoded text
6. Custom loader in `transloco-loader.ts` loads translations via HttpClient

### Runtime Validation (Zod)

1. Define schemas for API responses and form inputs
2. Use `.parse()` for validation with errors
3. Use `.safeParse()` for validation without throwing
4. Place schemas near their usage (models or services)
5. **Example**:

   ```typescript
   import { z } from 'zod';

   const ProjectSchema = z.object({
     id: z.string(),
     title: z.string(),
     description: z.string(),
   });

   type Project = z.infer<typeof ProjectSchema>;
   ```

### Constants and Configuration

1. **No Magic Strings**: Create constants for all hardcoded values
2. **Constants Location**:
   - Route paths → `shared/constants/routes.constants.ts`
   - API endpoints → `shared/constants/api.constants.ts`
   - Configuration values → `shared/constants/config.constants.ts`
   - App-wide constants → `shared/constants/app.constants.ts`
3. **Naming Convention**: Use SCREAMING_SNAKE_CASE for constants
4. **Organization**: Group related constants in objects or enums
5. **Type Safety**: Export const assertions with `as const` for literal types
6. **Example**:

   ```typescript
   // routes.constants.ts
   export const ROUTES = {
     HOME: '/',
     CASE_STUDIES: '/case-studies',
     CASE_STUDY_DETAIL: '/case-studies/:id',
   } as const;

   // api.constants.ts
   export const API_ENDPOINTS = {
     PROJECTS: '/assets/data/projects.json',
     GITHUB_API: 'https://api.github.com/graphql',
   } as const;
   ```

### Environment Configuration

1. Use Angular environment files for environment-specific config
2. Never commit secrets or API keys
3. Use environment variables for sensitive data
4. Create separate configs for dev/staging/prod
5. Access via `inject()` with InjectionToken

## Component Documentation (Storybook)

- Storybook is configured and ready to use
- Create stories as you build components
- Stories live in `.stories.ts` files next to components
- Document all component inputs, outputs, and variants
- Include accessibility notes in story descriptions
- Show different states (loading, error, empty, success)
- Storybook stories are required at component creation time (see Documentation & Tests section)
- **Example story structure**:

  ```typescript
  import type { Meta, StoryObj } from '@storybook/angular';
  import { ButtonComponent } from './button.component';

  const meta: Meta<ButtonComponent> = {
    title: 'Shared/Button',
    component: ButtonComponent,
    tags: ['autodocs'],
  };

  export default meta;
  type Story = StoryObj<ButtonComponent>;

  export const Primary: Story = {
    args: { variant: 'primary', label: 'Click me' },
  };
  ```

## Data Visualization

- Use **ngx-charts** for data visualizations
- Theme charts to match custom design system colors
- Integrate with GitHub GraphQL API for real-time data
- Chart types to implement:
  - Contribution calendar/heatmap
  - Repository statistics (stars, forks, issues)
  - Language usage breakdown
  - Commit activity over time
- Keep charts responsive and accessible
- Use loading states while fetching data

## CI/CD & Quality Gates

- GitHub Actions for automated workflows
- Run tests on every pull request
- Visual regression tests as part of CI
- Lighthouse CI for performance budgets
- Automated dependency updates
- Branch protection rules for main branch
- Required status checks before merge

## Performance Considerations

- All components use OnPush change detection
- Routes are lazy-loaded
- Use signals for fine-grained reactivity
- Avoid unnecessary subscriptions
- Use `trackBy` functions in loops

## Accessibility (WCAG 2.1 AAA)

### Required Standards

- **WCAG 2.1 Level AAA compliance** enforced via ESLint
- All accessibility violations must be fixed before merge
- Use automated tools:
  - ESLint accessibility rules (build-time)
  - Storybook a11y addon (component-level)
  - axe-core Playwright tests (E2E-level)

### Semantic HTML

- Always use semantic HTML5 elements (`<nav>`, `<main>`, `<article>`, `<section>`, etc.)
- Use `<button>` for actions, `<a>` for navigation
- Never use `<div>` or `<span>` for interactive elements

### ARIA

- Add ARIA labels to all interactive elements without visible text
- Use `aria-label`, `aria-labelledby`, or `aria-describedby` as appropriate
- Ensure form inputs have associated `<label>` elements
- Use `role` attribute only when semantic HTML isn't sufficient
- Never use positive `tabindex` values (only 0 or -1)

### Keyboard Navigation

- All interactive elements must be keyboard accessible
- Click events MUST have corresponding keyboard events
- Implement focus management for modals and dynamic content
- Ensure logical tab order
- Provide skip links for main content

### Color Contrast (AAA)

- Normal text: 7:1 contrast ratio minimum
- Large text (18pt+): 4.5:1 contrast ratio minimum
- UI components and graphics: 3:1 contrast ratio minimum
- Test with browser DevTools or WebAIM Contrast Checker

### Images & Media

- All images MUST have `alt` attributes
- Decorative images should have `alt=""`
- Provide captions and transcripts for video/audio
- Use `loading="lazy"` for below-fold images

### Forms

- Every input MUST have an associated label
- Use `<fieldset>` and `<legend>` for grouped inputs
- Provide clear error messages with `aria-invalid` and `aria-describedby`
- Never rely on color alone to indicate errors

### Testing

- Run `npm run lint` to catch template accessibility issues
- Check Storybook a11y addon for component violations
- Write Playwright tests using `e2e/fixtures/accessibility.ts`
- Example:

  ```typescript
  import { test, expect } from './fixtures/accessibility';

  test('page should be accessible', async ({ page, makeAxeBuilder }) => {
    await page.goto('/');
    const results = await makeAxeBuilder().analyze();
    expect(results.violations).toEqual([]);
  });
  ```

## Documentation Standards

### TSDoc Comments

- **ALWAYS** add TSDoc comments to:
  - All public component methods and properties
  - All service methods
  - Store methods and computed properties
  - Utility functions
  - Type definitions and interfaces
- Use `@param`, `@returns`, `@example` tags
- **Example**:

  ```typescript
  /**
   * Loads all projects from the data service.
   * @returns Observable of Project array
   * @example
   * this.projectService.getProjects().subscribe(projects => {...})
   */
  getProjects(): Observable<Project[]> {
    return this.http.get<Project[]>('/assets/data/projects.json');
  }
  ```

### Inline Comments

- Add comments for complex business logic
- Explain **why**, not **what**
- Keep comments up-to-date with code changes

### Continuous Documentation

- Update README when adding features
- Create ADRs (Architecture Decision Records) for major decisions
- Document API changes immediately
- Keep Storybook stories current

## Testing

### Unit Testing

- Write unit tests for components and services
- Test signal updates and component reactions
- Mock dependencies properly
- Use Angular testing utilities

### E2E Testing with Playwright

- Use Playwright for end-to-end tests
- Test critical user flows and navigation
- Run visual regression tests on Desktop (1920x1080), Laptop (1440x1024), Tablet (768x1024), and Mobile (375x667) viewports
- Screenshot tests ensure CSS Grid layouts don't break on smaller screens
- Store baseline screenshots in `e2e/screenshots-baseline/`
- Run E2E tests: `npm run test:e2e`
- Update visual baselines: `npm run test:e2e:update-snapshots`

## Build and Deploy

- Build: `npm run build`
- Dev server: `npm start`
- Lint: `npm run lint` (ESLint with accessibility rules)
- Lint fix: `npm run lint:fix` (auto-fix ESLint issues)
- Unit tests: `npm test` (Vitest configured)
- E2E tests: `npm run test:e2e`
- Update visual baselines: `npm run test:e2e:update-snapshots`
- Storybook: `npm run storybook`
- Build Storybook: `npm run build-storybook`
- API docs: `npm run docs` (Compodoc)
- Production builds are optimized and tree-shaken
- **Note**: Use `--legacy-peer-deps` when installing new packages

## Do's and Don'ts

### Do's

✅ Use signals for state management
✅ Use OnPush change detection everywhere
✅ Lazy load all feature routes
✅ Use CSS variables for all styling values
✅ Follow BEM naming convention
✅ Make all components standalone
✅ Use modern Angular control flow (@if, @for, @switch)
✅ Type everything properly
✅ Add TSDoc comments to all public APIs
✅ Create Storybook stories as you build components
✅ Use ng-icons for all icon needs (install specific icon packs as needed)
✅ Use Transloco for all user-facing text
✅ Use Zod for API response validation
✅ Ensure WCAG 2.1 AAA accessibility compliance
✅ Run `npm run lint` before committing
✅ Document as you go, not as an afterthought

### Don'ts

❌ Don't use NgModules (use standalone)
❌ Don't use structural directives (*ngIf, *ngFor)
❌ Don't hardcode colors or spacing values
❌ Don't skip change detection strategy
❌ Don't eagerly load feature routes
❌ Don't use `any` type
❌ Don't create global styles without CSS variables
❌ Don't use Angular Material (custom design system)
❌ Don't hardcode text strings (use Transloco)
❌ Don't create interactive elements without keyboard support
❌ Don't use positive tabindex values
❌ Don't omit alt text on images (use alt="" for decorative)
❌ Don't rely on color alone for information
❌ Don't defer documentation to the end
❌ Don't install packages without checking compatibility
❌ Don't commit code with ESLint errors
